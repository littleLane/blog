# CSRF(Cross-Site Request Forgery)

<a name="7ac32497"></a>
## 定义
CSRF（Cross-Site Request Forgery）是跨站请求伪造的缩写，又称 XSRF、One Click Attack 或者 Session Riding。它是一种挟制用户在当前已登录的 Web 应用程序上执行恶意操作的攻击方式。

与跨站网站脚本（XSS）相比，XSS 是利用了用户对指定网站的信任，而 CSRF 则是利用了网站对用户网页浏览器的信任，也就是说 CSRF 利用的是浏览器分不清楚发起请求的是不是真正的用户本人。

CSRF 是一种危害严重且常见的 Web 攻击，但是很多开发者都不了解它，而在实际的开发中往往忽略了这种攻击方式。

![csrf.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1560592030634-e21066e1-2517-4d65-9ba4-a42253d26b07.png#align=left&display=inline&height=346&name=csrf.png&originHeight=690&originWidth=1052&size=478149&status=done&width=528#align=left&display=inline&height=690&originHeight=690&originWidth=1052&status=done&width=1052)

<a name="f87a4966"></a>
## 攻击原理

<a name="814a456e"></a>
### 简单的 GET 攻击
一般比较简单的方式就是通过 GET 请求目标网站发起攻击：

- 1、用户 Alice 登录并访问某银行网站 A，并且服务器向浏览器成功写入 cookie
- 2、Alice 被某些信息诱导访问危险网站 B
- 3、危险网站 B 上有个 `<img>` 标签

```html
<img src="http://www.examplebank.com/account=Alice&amount=1000&payfor=Badman" >
```

- 4、这个标签的 src 属性值不是指向一张图片，而是指向一个 http 请求。我们都知道加载 img 标签时，就会发送一个地址为 src 属性值的 http 请求，所以这个请求向银行要求将 Alice 的 1000 元转给 Badman，由于 Alice 的浏览器上有 cookie，这样浏览器发出的这个请求就能得到响应并执行
- 5、最后的结果是 Alice 银行账户上的 1000 元被偷走了

> 或许这个恶意攻击的网站链接存在于 URL 或者其他可执行请求的标签属性上。


<a name="4b5f987e"></a>
### 进阶的 POST 攻击
上面我们说到的是一个利用 GET 请求发起攻击的方式。当然，除此之外，危害网站还可以伪造一个隐藏的表单提交发起 POST 请求的攻击。这个表单提交的操作是在恶意网站 onload 事件或者其他操作中触发的。

<a name="0d412b47"></a>
## 分析与防范
上面我们说到了关于 CSRF 攻击的两种攻击方式，在说关于 CSRF 防范之前，我们先来分析一下 CSRF 攻击涉及到的目标，从而对受害目标设法进行保护。

<a name="d805922e"></a>
### 攻击目标分析
从上面的图示中，我们不难发现，在整个 CSRF 攻击中涉及到黑客、受害者、恶意网站和目标网站。黑客发起 CSRF 攻击无非是想借助服务器对受害者浏览器中存储的授信 cookie 骗取服务器的信任，然后做一些危害性的操作。当然在整个过程中，由于浏览器同源策略的限制，黑客是拿不到 cookie 的。CSRF 主要影响的是数据修改的服务，所以我们需要保护的也就是数据修改的服务。而保护的关键就是验证，即在请求中加入黑客不能伪造的信息。

<a name="330f57cd"></a>
### 防范手段
<a name="b091ff52"></a>
#### POST 请求
一种最最基本的手段就是将数据修改性的服务方式改成 POST 请求。但是这种方式只能防范一些简单的 CSRF 攻击，而对稍微进阶点的 CSRF 攻击就无能为力了。前面我们也说到了通过提交隐藏的 Form 来达到 POST 请求攻击的案例，所以 POST 请求的方式还是不安全的，只能提高攻击的门槛。

优点：能防范一些简单的 CSRF 攻击，提高了攻击的门槛<br />缺点：不够安全，只能防范一些简单的 CSRF 攻击

<a name="322cda75"></a>
#### 验证码机制
在很多关于修改性的操作中，现在的网站服务都加入了验证码机制。通过添加验证码识别是不是用户主动或者自愿发起请求的。由于一定强度的验证码，机器是无法识别的，所以危险网站并不能伪造完成的请求。

优点：简单粗暴，低成本，可靠，能防范99.99%的攻击者<br />缺点：对用户不友好

<a name="26b1406c"></a>
#### 验证 HTTP Referer
在HTTP请求头信息中有一个叫 Referer 的字段，它记录了请求的来源地址。服务器需要做的就是验证这个来源地址是否合法，如果是来自一些不受信任的网站，则拒绝响应。

优点：零成本，简单易实现<br />缺点：由于这个方法严重依赖浏览器自身，因此安全性全看浏览器

- 1、兼容性不好：每个浏览器对于 Referer 的具体实现可能有差别
- 2、并不一定可靠：在一些古老的垃圾浏览器中，Referer 可以被篡改
- 3、对用户不友好：Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权。因此有些用户可能会开启浏览器防止跟踪功能，不提供 Referer，从而导致正常用户请求被拒绝

<a name="7f0bb1d6"></a>
#### 使用 Token
使用 token 来代替验证码验证。由于黑客并不能拿到和看到 cookie 里的内容，所以无法伪造一个完整的请求。基本思路如下：

- 1、服务器随机产生 token（比如把 cookie hash 化生成），存在 session 中，放在 cookie 中或者以 ajax 的形式交给前端
- 2、前端发请求的时候，解析 cookie 中的 token，放到请求 url 里或者请求头中
- 3、服务器验证 token，由于黑客无法得到或者伪造 token，所以能防范 csrf

更进一步的加强手段（不需要 session）：

- 1、服务器随机产生 token，然后以 token 为密钥散列生成一段密文
- 2、把 token 和密文都随 cookie 交给前端
- 3、前端发起请求时把密文和 token 都交给后端
- 4、后端对 token 和密文进行正向散列验证，看 token 能不能生成同样的密文
- 5、这样即使黑客拿到了 token 也无法拿到密文

优点：

- 1、安全性：极大地提高了破解成本（当然还是有办法破解），但是99%的攻击者看到散列的时候就已经望而生畏了。
- 2、易用性：非常容易实现。
- 3、友好性：对用户来说十分友好。

缺点：

- 1、性能担忧：需要hash计算，增加性能上的成本
- 2、cookie臃肿：更加依赖网络的情况
- 3、并不绝对安全：
  - 1、一些论坛之类支持用户自己发表内容，由于系统也会在这个地址后面加上token，这样黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。（进一步加强法可以防范，或者验证链接是否是链到自己本站的，是就在后面添加 token，如果是通向外网则不加）
  - 2、其他攻击方式如 XSS 攻击能拿到 cookie 和 token
- 4、对于 POST 请求，难以将 token 附在请求中。（可以通过框架和库解决）


<a name="b3048bbd"></a>
#### HTTP 请求头自定义属性验证
这种方法也是使用 token 并进行验证，和上一种方法不同的是把它放到 HTTP 头中自定义的属性里。

优点：

- 1、这样解决了上种方法在请求中加入 token 的不便
- 2、通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，安全性较高

缺点：

- 1、局限性非常大：XMLHttpRequest 请求通常用于 Ajax，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，造成不便。
- 2、对于旧网站，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

<a name="25f9c7fa"></a>
## 总结
因为 CSRF 攻击利用的是冲着浏览器分不清发起请求是不是真正的用户本人，所以防范的关键在于在请求中放入黑客所不能伪造的信息。从而防止黑客伪造一个完整的请求欺骗服务器。
