# 0.1 + 0.2 !== 0.3

<a name="8e1b944f"></a>
## 背景
在计算机编程领域，关于浮点数计算的坑时常会反复的碰到，比如说：0.1 + 0.2 等于 0.30000000000000004、0.8 * 7 等于 5.6000000000000005 等等。

那到底是什么造成了这样一个计算不准确的结果呢？这些就要涉及计算机基础的知识了，我们都知道在计算机中数据信息都是通过二进制编码（即 0 和 1 的组合）进行存储的，但是并不是所有的数据信息都可以用二进制编码进行准确的表示，比如一些浮点数。这样就会造成一系列的运算精度问题，导致运算的结果和实际的结果有偏差，这是大多数编程语言都存在的问题。

那在计算机中运行 0.1 + 0.2 到底是怎么一步一步进行并导致精度丢失的，接下来我们就来分析分析。

<a name="9dbb1e41"></a>
## 转换二进制
在我们的日常编码中遇到的数字计算无非就是整数和浮点数两种类型的数字运算，那就有两种类型的数据需要转换成二进制了：

- 整数转二进制：这个转换过程大家都应该很熟悉了，将数据一直除以 2，直至最后的商为 0，然后将每一步得到的余数（0 或 1）按逆序进行排列就得到了最终的二进制结果。

```javascript
// 这里以将十进制 10 转换为二进制为例:

10 除以 2   => 商 5 余 0
5  除以 2   => 商 2 余 1
2  除以 2   => 商 1 余 0
1  除以 2   => 商 0 余 1

最终所得二进制结果为：1010
```

- 浮点数转二进制：浮点数分整数和小数两个部分，在进行二进制转换时需将两个部分分开进行处理。整数部分转二进制和上面整数转二进制的方法一致，小数部分需要一直乘以 2，直至小数部分的结果为 0，然后取出每步运算中的整数部分，按逆序进行排序（若小数部分最终都无法为零，根据有效位数要求取得相应数值，位数后一位0 舍 1 入进行取舍）。

```javascript
// 这里以将十进制 0.1 转换为二进制为例:

0.1 乘以 2   => 得 0.2 整数部分 0
0.2 乘以 2   => 得 0.4 整数部分 0
0.4 乘以 2   => 得 0.8 整数部分 0
0.8 乘以 2   => 得 1.6 整数部分 1
0.6 乘以 2   => 得 1.2 整数部分 1
0.2 乘以 2   => 得 0.4 整数部分 0
0.4 乘以 2   => 得 0.8 整数部分 0
0.8 乘以 2   => 得 1.6 整数部分 1
0.6 乘以 2   => 得 1.2 整数部分 1
......
```

上面例子算了一通发现小数部分再怎么继续进行原酸都不会等于 0，所以使用二进制并没办法精确表示 0.1<br />那么 0.1 的二进制表示是：0.000110011......0011...... (0011无限循环)<br />而 0.2 的二进制表示则是：0.00110011......0011...... (0011无限循环)<br />既然 0.1 和 0.2 的二进制表示都是无限循环的，那么最终他们会展示到多少位呢，这就是传说中的 IEEE754 标准了。

<a name="cc6c1f78"></a>
## IEEE754 标准
IEEE754 标准是 IEEE 二进位浮点数算术标准 (IEEE Standard for Floating-Point Arithmetic) 的标准编号。IEEE754 标准规定了计算机程序设计环境中的二进制和十进制的浮点数自述的交换、算术格式以及方法。根据IEEE 754标准，任意一个二进制浮点数都可以表示成以下形式：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1554606569135-eaee4648-a011-45a8-89be-613a0d6e2ba4.png#align=left&display=inline&height=53&name=image.png&originHeight=45&originWidth=295&size=5508&status=done&width=349)

- S 为数符，它表示浮点数的正负（0正1负）；
- M 为有效位（尾数）；
- E 为阶码，用移码表示，阶码的真值都被加上一个常数（偏移量）。

尾数部分 M 通常都是规格化表示的，即非 0 的尾数其第一位总是 1，而这一位也称隐藏位，因为存储时候这一位是会被省略的。比如保存 1.0011 时，只保存 0011，等读取的时候才把第一位的 1 加上，这样做相当于多保存了 1 位有效数字。

常用的浮点数格式有：

1、单精度

![image.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1554606972516-e0c5e8f7-2d87-484b-a373-142c2556a605.png#align=left&display=inline&height=90&name=image.png&originHeight=75&originWidth=500&size=51898&status=done&width=600)

这是 32 位的浮点数，最高的 1 位是符号位 S，后面的 8 位是指数 E，剩下的 23 位为尾数（有效数字）M；其**真值**为：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1554607123809-b23f9374-7da9-496d-966d-574de0e08a58.png#align=left&display=inline&height=35&name=image.png&originHeight=29&originWidth=363&size=5089&status=done&width=440)

2、双精度

![image.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1554607029021-28ae1520-ed5c-420e-aca6-0d142e7f5df7.png#align=left&display=inline&height=121&name=image.png&originHeight=125&originWidth=618&size=9854&status=done&width=600)<br />
<br />这是 64 位的浮点数，最高的 1 位是符号位 S，后面的 11 位是指数 E，剩下的 52 位为尾数（有效数字）M；其**真值**为：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/114852/1554607217390-b7f7e824-d0a2-47ee-8bb4-f991702d18cf.png#align=left&display=inline&height=43&name=image.png&originHeight=28&originWidth=286&size=4491&status=done&width=440)

在 JavaScript 中只有一种数字类型 number，而 number 使用的就是 IEEE 754 双精度浮点格式。依据上述规则，0.1 和 0.2 的存储形式如下：<br />

- 0.1：因为是正数，所以符号位是 0；而其二进制位是 0.000110011......0011...... (0011无限循环)，对其进行规格化后为 1.10011001......1001(1)*2^-4，根据 **0舍1入** 的规则，最后的值为

      2^-4 * 1.1001100110011001100110011001100110011001100110011010<br />      而指数 E = -4 + 1023 = 1019，由此可得，JavaScript 中 0.1 的二进制存储格式为：<br />     (其中符号位用逗号分隔，指数位用分号分隔)：   0,01111111011;1001100110011001100110011001100110011001100110011010

- 0.2：0,01111111100;1001100110011001100110011001100110011001100110011010

<a name="68c353ef"></a>
## 浮点数运算
0.1 => 0,01111111011;1001100110011001100110011001100110011001100110011010<br />0.2 => 0,01111111100;1001100110011001100110011001100110011001100110011010<br />**浮点数的加减运算按以下几步进行**：

- 1、对阶，使两数的小数点位置对齐（也就是使两数的阶码相等）。要先求阶差，阶小的尾数要根据阶差来右移（尾数位移时可能会发生数丢失的情况，影响精度），因为 0.1 和0.2的阶码和尾数均为正数，所以它们的原码、反码及补码都是一样的。（使用补码进行运算，计算过程中使用双符号）。△阶差(补码) = 00,01111111011 - 00,01111111100 = 00,01111111011 + 11,10000000100 = 11,11111111111，由上可知△阶差为 -1，也就是 0.1 的阶码比 0.2 的小，所以要把 0.1 的尾数右移 1 位，阶码加 1（使 0.1 的阶码和0.2 的一致）。最后 0.1 => 0,01111111100;1100110011001100110011001100110011001100110011001101(0)
> 注：要注意0舍1入的原则。之所以右移一位，尾数补的是1，是因为隐藏位的数值为1（默认是不存储的，只有读取的时候才加上）

- 2、尾数求和

```javascript
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
  ——————————————————————————————
  10.0110011001100110011001100110011001100110011001100111
```

- 3、规格化

针对步骤2的结果，需要右规（即尾数右移1位，阶码加1）<br />sum = 0.1 + 0.2 = 0,01111111101;1.0011001100110011001100110011001100110011001100110011(1)<br />注：右规操作，可能会导致低位丢失，引起误差，造成精度问题。所以就需要步骤④的舍入操作

- 4、舍入（0舍1入）

sum = 0,01111111101;1.0011001100110011001100110011001100110011001100110100

- 5、溢出判断

根据阶码判断浮点运算是否溢出。而我们的阶码01111111101即不上溢，也不下溢。

至此，0.1+0.2 的运算就已经结束了。接下来，我们一起来看看上面计算得到的结果，它的十进制数是多少。<br /><1> 先将它非规格化，得到二进制形式：<br />sum = 0.010011001100110011001100110011001100110011001100110100<br /><2> 再将其转成十进制<br />sum = 2^2 + 2^5 + 2^6 + ... + 2^52 = 0.30000000000000004440892098500626

现在你应该明白 JavaScript 中 0.30000000000000004 这个结果怎么来的吧。

<a name="5dc99f6e"></a>
## 问题
Q1：指数位E（阶码）为何用移码表示？<br />A1：为了便于判断其大小。<br />_<br />Q2：计算机运算为何要使用补码？<br />A2：可以简化计算机的运算步骤，且只用设加法器，如做减法时若能找到与负数等价的正数来代替该负数，就可以把减法操作用加法代替。而采用补码，就能达到这个效果。

<a name="0ea1357c"></a>
## 解决浮点数精度问题
1、转整数计算<br />以 0.1 + 0.2 为例子，我们可以先将 0.1 乘以 10 转成 1，0.2 乘以 10 转成 2，然后计算 1 + 2，结果得 3，转成最终的结果为 3 / 10 = 0.3，这样精度就不会丢失了。

2、ES6 新特性<br />ES6 为 Number 新增一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的 1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。Number.EPSILON 实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。于是，我们就可以利用 Number.EPSILON 来判断 0.1 + 0.2 是否等于 0.3 了。

3、借助第三方库<br />如果你需要非常精确的结果，可以考虑使用特殊的进制数据类型，如这个叫 [bignumber](https://github.com/MikeMcl/bignumber.js) 的类库。

4、如果你对精度要求不高可以调用 round() 方法四舍五入或者 toFixed() 方法保留指定的位数。
