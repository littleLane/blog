<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue $dispatch 和 $broadcast | LittleLane</title>
    <meta name="description" content="LittleLane的博客">
    <link rel="manifest" href="/blog/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog/assets/css/0.styles.fb084c9e.css" as="style"><link rel="preload" href="/blog/assets/js/app.8628b115.js" as="script"><link rel="preload" href="/blog/assets/js/37.13db91e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.7c696101.js"><link rel="prefetch" href="/blog/assets/js/11.0789c73b.js"><link rel="prefetch" href="/blog/assets/js/12.461a1f52.js"><link rel="prefetch" href="/blog/assets/js/13.fe3225de.js"><link rel="prefetch" href="/blog/assets/js/14.90707970.js"><link rel="prefetch" href="/blog/assets/js/15.fe5adc74.js"><link rel="prefetch" href="/blog/assets/js/16.0ebb9344.js"><link rel="prefetch" href="/blog/assets/js/17.9ccc244d.js"><link rel="prefetch" href="/blog/assets/js/18.3280c375.js"><link rel="prefetch" href="/blog/assets/js/19.497df057.js"><link rel="prefetch" href="/blog/assets/js/2.a2883561.js"><link rel="prefetch" href="/blog/assets/js/20.32678c14.js"><link rel="prefetch" href="/blog/assets/js/21.1423f536.js"><link rel="prefetch" href="/blog/assets/js/22.f2e999a8.js"><link rel="prefetch" href="/blog/assets/js/23.ba5456dd.js"><link rel="prefetch" href="/blog/assets/js/24.506605c5.js"><link rel="prefetch" href="/blog/assets/js/25.a207ec0f.js"><link rel="prefetch" href="/blog/assets/js/26.2ef516a2.js"><link rel="prefetch" href="/blog/assets/js/27.0fc3d0a8.js"><link rel="prefetch" href="/blog/assets/js/28.857b9f54.js"><link rel="prefetch" href="/blog/assets/js/29.ddc54fa4.js"><link rel="prefetch" href="/blog/assets/js/3.03546f42.js"><link rel="prefetch" href="/blog/assets/js/30.d40e6ea0.js"><link rel="prefetch" href="/blog/assets/js/31.1195eb55.js"><link rel="prefetch" href="/blog/assets/js/32.8de16a5a.js"><link rel="prefetch" href="/blog/assets/js/33.7cd7fe57.js"><link rel="prefetch" href="/blog/assets/js/34.738f5bc5.js"><link rel="prefetch" href="/blog/assets/js/35.77dd47e7.js"><link rel="prefetch" href="/blog/assets/js/36.352ec5b1.js"><link rel="prefetch" href="/blog/assets/js/38.c6fc1157.js"><link rel="prefetch" href="/blog/assets/js/39.8c2096af.js"><link rel="prefetch" href="/blog/assets/js/4.230e5792.js"><link rel="prefetch" href="/blog/assets/js/40.b2aa99ad.js"><link rel="prefetch" href="/blog/assets/js/41.b6c8edd8.js"><link rel="prefetch" href="/blog/assets/js/42.44ad0cc7.js"><link rel="prefetch" href="/blog/assets/js/43.fb6bd8dc.js"><link rel="prefetch" href="/blog/assets/js/44.f45a0bfd.js"><link rel="prefetch" href="/blog/assets/js/45.3ac2cc18.js"><link rel="prefetch" href="/blog/assets/js/46.763aa6cb.js"><link rel="prefetch" href="/blog/assets/js/47.949030e9.js"><link rel="prefetch" href="/blog/assets/js/48.54ad9db1.js"><link rel="prefetch" href="/blog/assets/js/5.e8583280.js"><link rel="prefetch" href="/blog/assets/js/6.34b724f6.js"><link rel="prefetch" href="/blog/assets/js/7.1c9ebf74.js"><link rel="prefetch" href="/blog/assets/js/8.928845ca.js"><link rel="prefetch" href="/blog/assets/js/9.aac799a8.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.fb084c9e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">LittleLane</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/AboutMe/" class="nav-link">关于我</a></div> <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/AboutMe/" class="nav-link">关于我</a></div> <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav> <div class="carbon-ads"></div> <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/" class="sidebar-link">Home</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>JavaScript</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/JavaScript/0x00.html" class="sidebar-link">函数一等公民</a></li><li><a href="/blog/JavaScript/0x01.html" class="sidebar-link">回调函数详解</a></li><li><a href="/blog/JavaScript/0x02.html" class="sidebar-link">高阶函数</a></li><li><a href="/blog/JavaScript/0x03.html" class="sidebar-link">重学 new 操作符</a></li><li><a href="/blog/JavaScript/0x04.html" class="sidebar-link">重学 call、apply</a></li><li><a href="/blog/JavaScript/0x05.html" class="sidebar-link">重学 bind</a></li><li><a href="/blog/JavaScript/0x06.html" class="sidebar-link">重学 Array 之基础概念</a></li><li><a href="/blog/JavaScript/0x07.html" class="sidebar-link">重学 Array 之元素增删</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>DSA</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/" class="sidebar-link">Home</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/" class="sidebar-link">Home</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>Tools</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/Tools/Vue-0x00.html" class="sidebar-link">Vue 组件通信详解</a></li><li><a href="/blog/Tools/Vue-0x01.html" class="sidebar-link">v-model 实现原理</a></li><li><a href="/blog/Tools/Vue-0x02.html" class="active sidebar-link">Vue $dispatch 和 $broadcast</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/Tools/Vue-0x02.html#_00-前言" class="sidebar-link">00 前言</a></li><li class="sidebar-sub-header"><a href="/blog/Tools/Vue-0x02.html#_01-dispatch-详解" class="sidebar-link">01 $dispatch 详解</a></li><li class="sidebar-sub-header"><a href="/blog/Tools/Vue-0x02.html#_10-broadcast-详解" class="sidebar-link">10 $broadcast 详解</a></li><li class="sidebar-sub-header"><a href="/blog/Tools/Vue-0x02.html#_11-总结" class="sidebar-link">11 总结</a></li></ul></li><li><a href="/blog/Tools/Vue-0x03.html" class="sidebar-link">Vue v-model 源码解析</a></li><li><a href="/blog/Tools/Vue-0x04.html" class="sidebar-link">v-model 后续 input and change</a></li><li><a href="/blog/Tools/Vue-0x05.html" class="sidebar-link">Vue 生命周期详解</a></li><li><a href="/blog/Tools/Vue-0x06.html" class="sidebar-link">Vue.use() 做了什么？</a></li><li><a href="/blog/Tools/Vue-0x07.html" class="sidebar-link">Vue Router 实现剖析之一</a></li><li><a href="/blog/Tools/Vue-0x08.html" class="sidebar-link">Vue Router 实现剖析之二</a></li><li><a href="/blog/Tools/Vue-0x09.html" class="sidebar-link">Vue Router 实现剖析之三</a></li><li><a href="/blog/Tools/Vue-0x0A.html" class="sidebar-link">Vue Router 实现剖析之五</a></li><li><a href="/blog/Tools/Vue-0x0B.html" class="sidebar-link">数据响应式初探</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>DailyQuestion</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/DailyQuestion/0x00.html" class="sidebar-link">['1', '2', '3'].map(parseInt)</a></li><li><a href="/blog/DailyQuestion/0x01.html" class="sidebar-link">git ssh Permission denied</a></li><li><a href="/blog/DailyQuestion/0x02.html" class="sidebar-link">0.1 + 0.2 !== 0.3</a></li><li><a href="/blog/DailyQuestion/0x03.html" class="sidebar-link">聊聊 a 标签 rel 属性值</a></li><li><a href="/blog/DailyQuestion/0x04.html" class="sidebar-link">浏览器路由 API 详解</a></li><li><a href="/blog/DailyQuestion/0x05.html" class="sidebar-link">VSCode nvm 问题</a></li><li><a href="/blog/DailyQuestion/0x06.html" class="sidebar-link">涉及 new 、this、以及原型链经典习题</a></li><li><a href="/blog/DailyQuestion/0x07.html" class="sidebar-link">DBeaver MySQL 问题集</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>BestPractices</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/" class="sidebar-link">Home</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>SafeOptimize</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/SafeOptimize/0x00.html" class="sidebar-link">JavaScript 加载与执行</a></li><li><a href="/blog/SafeOptimize/0x01.html" class="sidebar-link">函数节流</a></li><li><a href="/blog/SafeOptimize/0x02.html" class="sidebar-link">XSS（Cross-Site Scripting）</a></li><li><a href="/blog/SafeOptimize/0x03.html" class="sidebar-link">CSRF(Cross-Site Request Forgery)</a></li><li><a href="/blog/SafeOptimize/0x04.html" class="sidebar-link">深入函数节流</a></li><li><a href="/blog/SafeOptimize/0x05.html" class="sidebar-link">js 异步加载之 async 和 defer</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-dispatch-和-broadcast"><a href="#vue-dispatch-和-broadcast" aria-hidden="true" class="header-anchor">#</a> Vue $dispatch 和 $broadcast</h1> <p><a name="70761d53"></a></p> <h2 id="_00-前言"><a href="#_00-前言" aria-hidden="true" class="header-anchor">#</a> 00 前言</h2> <p>$dispatch 和 $broadcast 作为一对情侣 💑属性，在 Vue 1.0 中主要用来实现基于组件树结构的事件流通信 —— 通过向上或向下以冒泡的形式传递事件流，以实现嵌套父子组件的通信。但是由于其显功能缺陷，在 Vue 2.0 中就被移除了。虽然 Vue 官网已经不再支持使用 $dispatch 和 $broadcast 进行组件通信，但是在很多基于 Vue 的 UI 框架中都有对其的封装，包括 <a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener noreferrer"><strong>element-ui</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://github.com/iview/iview" target="_blank" rel="noopener noreferrer">iview<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 等等。</p> <p>那么 $dispatch 和 $broadcast 到底是怎么工作，其底层又是怎么实现的呢？接下来，我们就详细的说一说！</p> <p><a name="175d38a3"></a></p> <h2 id="_01-dispatch-详解"><a href="#_01-dispatch-详解" aria-hidden="true" class="header-anchor">#</a> 01 $dispatch 详解</h2> <p>为了追根溯源，我们还是先去 Vue 1.0 的文档你观摩一下其概念吧！</p> <blockquote><p><strong>概念：</strong></p></blockquote> <p><em><strong>Dispatch an event, first triggering it on the instance itself, and then propagates upward along the parent chain. The propagation stops when it triggers a parent event listener, unless that listener returns <strong><strong><code>true</code></strong></strong>. Any additional arguments will be passed into the listener’s callback function.</strong><br></em><br>上面的一段英文定义来自 Vue 1.0 官方文档，其大致的意思是说：<strong>dispatch 是一个事件，首先会在自己实例本身上触发，然后沿父链向上传播。当它触发父组件上的事件侦听器时传播即会停止，除非该侦听器返回 true。 任何其他参数都将传递给侦听器的回调函数。</strong></p> <blockquote><p><strong>参数：</strong></p></blockquote> <p>dispatch 会接收两中参数：event 是事件名称，[...args] 是触发事件时传递给回调函数的参数。</p> <blockquote><p><strong>例子：</strong></p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 创建一个 parent 组件</span>
<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个 child1 组件，其父组件指向 parent</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> parent<span class="token punctuation">:</span> parent <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个 child2 组件，其父组件指向 child1</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> parent<span class="token punctuation">:</span> child1 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在 parent 组件监听名为 test 的事件，并绑定了一个回调函数</span>
parent<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent notified'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在 child1 组件监听名为 test 的事件，并绑定了一个回调函数</span>
child1<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child1 notified'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在 child2 组件监听名为 test 的事件，并绑定了一个回调函数</span>
child2<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child2 notified'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>说到这里，parent、child1 和 child2 三个组件之间的关系可以展示成如下的关系图：<br> <img src="https://cdn.nlark.com/yuque/0/2019/png/114852/1551870035081-a5c673d4-9ed2-4e31-96b2-343c54c0b449.png#align=left&display=inline&height=362&name=%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%20%284%29.png&originHeight=370&originWidth=194&size=4444&status=done&width=190" alt="高阶组件 (4).png"><br></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 在 child2 组件中通过 dispatch 触发 test 事件</span>
child2<span class="token punctuation">.</span><span class="token function">$dispatch</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 事件执行会输出如下结果</span>
<span class="token comment">// -&gt; &quot;child2 notified&quot;</span>
<span class="token comment">// -&gt; &quot;child1 notified&quot;</span>
</code></pre></div><p>当执行 child2.$dispatch('test'); 时，首先会触发 child2 组件里面监听的 test 事件的回调函数，输出 'child2 notified'，根据上面官方文档的定义，事件会沿着组件关系链一直向上传递，然后传递到 child1 组件，触发监听事件输出 &quot;child1 notified&quot;，但是该侦听器没有返回 true，所以事件传递到此就结束了，最终的输出结果就只有 &quot;child2 notified&quot; 和 &quot;child1 notified&quot;。</p> <blockquote><p><strong>Vue 1.0 官方实现</strong></p></blockquote> <p>在 Vue 1.0 版本中，$dispatch 实现的源码放在 /src/instance/api/events.js 文件中，代码很简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * Recursively propagate an event up the parent chain.
 * 递归地在父链上传播事件。
 * @param {String} event
 * @param {...*} additional arguments
 */</span>
<span class="token comment">// $dispatch 方法是定义在 Vue 的 prototype 上的</span>
<span class="token comment">// 接受一个字符串类型的事件名称</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$dispatch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 首先执行 $emit 触发事件，将返回值保存在 shouldPropagate 中</span>
  <span class="token keyword">var</span> shouldPropagate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
  
  <span class="token comment">// 如果首次执行的 $emit 方法返回的值不是 true 就直接返回</span>
  <span class="token comment">// 如果返回值不是 true 就说明组件逻辑不希望事件继续往父组件进行传递</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldPropagate<span class="token punctuation">)</span> <span class="token keyword">return</span>
  
  <span class="token comment">// 如果首次执行 $emit 方法返回值是 true 就获取当前组件的 parent 组件实例</span>
  <span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent
  
  <span class="token comment">// 将函数接受的参数转换成数组</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  
  <span class="token comment">// use object event to indicate non-source emit on parents</span>
  <span class="token comment">// 根据传入的事件名称的参数组装成 object</span>
  args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> event<span class="token punctuation">,</span> source<span class="token punctuation">:</span> <span class="token keyword">this</span> <span class="token punctuation">}</span>
  
  <span class="token comment">// 循环知道组件的父组件</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在父组件中执行 $emit 触发事件</span>
    shouldPropagate <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    
    <span class="token comment">// 如果父组件 $emit 返回的是 true 就继续递归祖父组件，否则就停止循环</span>
    parent <span class="token operator">=</span> shouldPropagate <span class="token operator">?</span> parent<span class="token punctuation">.</span>$parent <span class="token punctuation">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 最后返回当前组件实例</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>element-ui 实现</strong></p></blockquote> <p>在 Element-UI 中，$dispatch 实现的源码放在 /src/mixins/emitter.js 文件中，代码很简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义 dispatch 方法，接受三个参数，分别是：组件名称、将要触发的事件名称、回调函数传递的参数</span>
<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token parameter">componentName<span class="token punctuation">,</span> eventName<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取基于当前组件的父组件实例，这里对父组件实例和根组件实例做了兼容处理</span>
  <span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$root<span class="token punctuation">;</span>
  
  <span class="token comment">// 通过父组件的 $option 属性获取组件的名称</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>componentName<span class="token punctuation">;</span>

  <span class="token comment">// 当相对当前组件的父组件实例存在，而且当父组件的名称不存在或者父组件的名称不等于传入的组件名称时，执行循环</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>name <span class="token operator">||</span> name <span class="token operator">!==</span> componentName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录父组件的父组件</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">;</span>

    <span class="token comment">// 当父组件的父组件存在时，获取祖父组件的名称</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      name <span class="token operator">=</span> parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>componentName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 当循环结束是，parent 的值就是最终匹配的组件实例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 parent 值存在时调用 $emit 方法</span>
    <span class="token comment">// 传入 parent 实例、事件名称与 params 参数组成的数组</span>
    <span class="token comment">// 触发传入事件名称 eventName 同名的事件</span>
    parent<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>差异分析</strong></p></blockquote> <p>仔细看完实现 $dispatch 方式的两个版本的代码，大家是不是发现，两个版本的实现和功能差异性还是很大的。</p> <ul><li><p>1、接受参数：Vue 实现版本只会接受一个字符串类型的事件名称为参数，而 element-ui 实现的版本会接受三个参数，分别是：需要触发事件的组件名称、将要触发的事件名称、回调函数传递的参数；</p></li> <li><p>2、实现功能：Vue 实现版本触发事件一直会顺着组件链向上进行传递，知道父组件中的侦听器没有返回 true，在这个期间所有的组件都会执行事件的响应，包括当前组件本身，而 element-ui 实现版本会不断的基于当前组件向父组件进行遍历，直至找到和接受的组件名称匹配，就会停止遍历，触发匹配组件中的监听事件。</p></li></ul> <p><a name="3d7550fe"></a></p> <h2 id="_10-broadcast-详解"><a href="#_10-broadcast-详解" aria-hidden="true" class="header-anchor">#</a> 10 $broadcast 详解</h2> <p>上面详细的说完 $dispatch 方法的实现和 Vue 实现版本与 element-ui 实现版本的区别，下面就该说说 $broadcast，毕竟他们是情侣属性嘛。</p> <blockquote><p><strong>概念</strong></p></blockquote> <p><em>Broadcast an event that propagates downward to all descendants of the current instance. Since the descendants expand into multiple sub-trees, the event propagation will follow many different “paths”. The propagation for each path will stop when a listener callback is fired along that path, unless the callback returns <em><code>_true_</code></em><strong>.</strong></em><br><br>Broadcast 是一个事件，它向下传播到当前实例的所有后代。由于后代扩展为多个子树，事件传播将会遵循许多不同的“路径”。 除非回调返回 true，否则在沿该路径触发侦听器回调时，每个路径的传播将会停止。</p> <blockquote><p><strong>参数</strong></p></blockquote> <p><br>broadcast 会接收两中参数：event 是事件名称，[...args] 是触发事件时传递给回调函数的参数。</p> <blockquote><p><strong>例子</strong></p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 创建 parent 组件实例</span>
<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 创建 child1 组件实例，其父组件指向 parent</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> parent<span class="token punctuation">:</span> parent <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 创建 child2 组件实例，其父组件指向 parent</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> parent<span class="token punctuation">:</span> parent <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 创建 child3 组件实例，其父组件指向 child2</span>
<span class="token keyword">var</span> child3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> parent<span class="token punctuation">:</span> child2 <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 在 child1 组件监听名为 test 的事件，并绑定了一个回调函数</span>
child1<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child1 notified'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 在 child2 组件监听名为 test 的事件，并绑定了一个回调函数</span>
child2<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child2 notified'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 在 child3 组件监听名为 test 的事件，并绑定了一个回调函数</span>
child3<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child3 notified'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>parent、child1、child2 和 child3 四个组件之间的关系可以展示成如下的关系图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/114852/1551875942057-18c8899a-6c5c-4015-a4f7-38f2e755dcc1.png#align=left&display=inline&height=363&name=%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%20%285%29.png&originHeight=399&originWidth=345&size=8819&status=done&width=314" alt="高阶组件 (5).png"></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>parent<span class="token punctuation">.</span><span class="token function">$broadcast</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; &quot;child1 notified&quot;</span>
<span class="token comment">// -&gt; &quot;child2 notified&quot;</span>
</code></pre></div><p>当执行 parent.$broadcast('test'); 时，事件流会以 parent 组件为起点向 parent 的子组件进行传递，根据事件绑定的顺序，虽然 parent 组件有两个同级的 child1 和 child2 ，但是事件流会先触发 child1 里面的绑定事件，此时会输出 &quot;child1 notified&quot;，然后事件流到达 child2 组件，会触发 child2 组件中的绑定事件，输出 &quot;child2 notified&quot;。到这时，child2 组件中的侦听器并没有返回 true，所以事件传递到此就结束了，最终的输出结果就只有 &quot;child1 notified&quot; 和 &quot;child2 notified&quot;。</p> <blockquote><p><strong>Vue 1.0 官方实现</strong></p></blockquote> <p><br>在 Vue 1.0 版本中，$broadcast 实现的源码放在 /src/instance/api/events.js 文件中，代码很简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * Recursively broadcast an event to all children instances.
 * 递归地向所有子实例广播事件。
 * @param {String|Object} event
 * @param {...*} additional arguments
 */</span>
<span class="token comment">// $dispatch 方法是定义在 Vue 的 prototype 上的</span>
<span class="token comment">// 接受一个事件</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$broadcast</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取传入事件的类型，判断是否为字符串</span>
  <span class="token keyword">var</span> isSource <span class="token operator">=</span> <span class="token keyword">typeof</span> event <span class="token operator">===</span> <span class="token string">'string'</span>
  
  <span class="token comment">// 校正 event 的值，当接受 event 的类型为字符串时就直接使用，如果不是字符串就使用 event 上的 name 属性 </span>
  event <span class="token operator">=</span> isSource <span class="token operator">?</span> event <span class="token punctuation">:</span> event<span class="token punctuation">.</span>name
  
  <span class="token comment">// if no child has registered for this event,</span>
  <span class="token comment">// then there's no need to broadcast.</span>
  <span class="token comment">// 如果当前组件的子组件没有注册该事件，就直接返回，并不用 broadcast</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>_eventsCount<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
  
  <span class="token comment">// 获取当前组件的子组件</span>
  <span class="token keyword">var</span> children <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$children
  
  <span class="token comment">// 将函数接受的参数转换成数组</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  
  <span class="token comment">// 如果传入事件为字符串</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// use object event to indicate non-source emit</span>
    <span class="token comment">// on children</span>
    <span class="token comment">// 根据传入的事件名称的参数组装成 object</span>
    args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> event<span class="token punctuation">,</span> source<span class="token punctuation">:</span> <span class="token keyword">this</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 循环子组件</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    
    <span class="token comment">// 在每个子组件中调用 $emit 触发事件</span>
    <span class="token keyword">var</span> shouldPropagate <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    
    <span class="token comment">// 判断调用 $emit 返回的值是否为 true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldPropagate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果调用 $emit 返回的值为 true，就递归孙子组件继续广播</span>
      child<span class="token punctuation">.</span><span class="token function">$broadcast</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 最后返回当前组件的实例</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>element-ui 实现</strong></p></blockquote> <p><br>在 Element-UI 中，$broadcast 实现的源码放在 /src/mixins/emitter.js 文件中，代码很简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 定义 broadcast 方法，接受三个参数，分别是：组件名称、将要触发的事件名称、回调函数传递的参数</span>
<span class="token keyword">function</span> <span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token parameter">componentName<span class="token punctuation">,</span> eventName<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 依次循环当前组件的子组件</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取每个子组件的名字</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> child<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>componentName<span class="token punctuation">;</span>

    <span class="token comment">// 判断子组件的名字是否等于传入的组件名称</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">===</span> componentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果子组件的名字等于传入的组件名称就调用 $emit 触发事件</span>
      child<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果子组件的名字不等于传入的组件名称就递归遍历调用 broadcast 孙子组件</span>
      <span class="token function">broadcast</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token punctuation">[</span>componentName<span class="token punctuation">,</span> eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>params<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>差异分析</strong></p></blockquote> <p><br>和之前说到的 $dispatch 一样，这里的 $broadcast 的两个实现版本也存在着巨大的差异：</p> <ul><li><p>1、接受参数：Vue 实现版本只会接受一个字符串类型的事件名称为参数，而 element-ui 实现的版本会接受三个参数，分别是：需要触发事件的组件名称、将要触发的事件名称、回调函数传递的参数；</p></li> <li><p>2、实现功能：Vue 实现的 $broadcast 触发方式是<strong>默认</strong>只触发子代组件，不触发孙子代组件，如果子代创建了监听且返回了true，才会向孙子代组件传递事件。而 element-ui 实现的版本是直接向所有子孙后代组件传递，直至获取到的子组件名称等于传入的组件名称相等，才会触发当前子组件的监听事件，期间也没有返回值的判定。</p></li></ul> <p><a name="bbe8fac5"></a></p> <h2 id="_11-总结"><a href="#_11-总结" aria-hidden="true" class="header-anchor">#</a> 11 总结</h2> <p>说到这里，$dispatch 和 $broadcast 的讲解就结束了。可能大家已经知道了 Vue 2.0 版本为什么会将这两个属性移除。首先我们引入<a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener noreferrer">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的说法：</p> <p><em>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且 <strong><code>$dispatch</code></strong> 和 <strong><code>$broadcast</code></strong> 也没有解决兄弟组件间的通信问题。</em><br><br>这样来说 $dispatch 和 $broadcast 确实会有这样的问题。在前面的讲解中，大家也不难发现 $dispatch 主要是事件流由当前组件往父组件流动，当满足一定条件的时候就会触发当前子组件的监听事件，$broadcast 的功能是事件流由当前组件向子组件流动，当满足一定条件的时候就会触发当前子组件的监听事件。也就是说 $dispatch 和 $broadcast 主要解决了父子组件、嵌套父子组件的通信，并没有解决兄弟组件的通信问题，另一个方面这样的事件流动的方式是基于组件树结构的，当业务越来越烦杂时，这种方式会显得极其繁琐，甚至会混乱到难以维护，所以 Vue 2.0 版本移除这两个 API 是在意料之中的。</p> <p>但是为什么三方 UI 库都会封装类似的这样一个组件通信的方式呢？我的猜测可能是为了解决在父子层嵌套组件中，通过 $dispatch 和 $broadcast 定向的向某个父或者子组件<strong>远程调用</strong>事件，这样就避免了通过传 props 或者使用 refs 调用组件实例方法的操作。这样说的话，$dispatch 和 $broadcast 也就其存在的价值，而并不是一无是处的，还是那句话：<strong>技术没有好与坏，只有合适不合适</strong>！</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">5/26/2019, 9:28:55 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/Tools/Vue-0x01.html" class="prev">
          v-model 实现原理
        </a></span> <span class="next"><a href="/blog/Tools/Vue-0x03.html">
          Vue v-model 源码解析
        </a>
        →
      </span></p></div> <div class="bsa-cpc-wrapper"><div class="bsa-cpc"></div></div></div> <!----></div></div>
    <script src="/blog/assets/js/app.8628b115.js" defer></script><script src="/blog/assets/js/37.13db91e9.js" defer></script>
  </body>
</html>
