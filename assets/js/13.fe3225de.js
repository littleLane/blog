(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{198:function(t,n,a){"use strict";a.r(n);var s=a(0),e=Object(s.a)({},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),a("p",[t._v("在我的另一个关于 JavaScript 的专栏中，有一篇讲到了 new 操作符的作用以及实现 —— "),a("a",{attrs:{href:"https://www.yuque.com/littlelane/javascript/nqloa2",target:"_blank",rel:"noopener noreferrer"}},[t._v("重学 new 操作符"),a("OutboundLink")],1),t._v("，这里我们就趁热打铁来一打相关的经典练习题讲解吧。如果你还没有看过"),a("a",{attrs:{href:"https://www.yuque.com/littlelane/javascript/nqloa2",target:"_blank",rel:"noopener noreferrer"}},[t._v("重学 new 操作符"),a("OutboundLink")],1),t._v("或者对 new 操作符还是一知半解，那强烈建议你先去看看，然后回过头来接着看习题。")]),t._v(" "),a("p",[t._v("假设你已将搞清楚了 new 操作符的原理了，那我们就接着继续看吧！")]),t._v(" "),a("p",[t._v("首先来一段代码展示一下习题：")]),t._v(" "),t._m(1),t._m(2),t._v(" "),a("p",[t._v("上面的代码我们按块就分析了个遍，我们就不看下面的题目，先分析一下上面这些定义中有哪些坑点：")]),t._v(" "),t._m(3),t._v(" "),a("p",[t._v("扒出了上面代码可能存在的坑点，我们再来看下面一系列函数调用，就更简单了。")]),t._v(" "),t._m(4),a("p",[t._v("大家可以先自主的分析一下上面各调用会输出什么，然后接着往下面，对一下输出结果，看自己哪里错了！")]),t._v(" "),a("p",[t._v("好了，五分钟过去了，假设大家经过一遍分析之后，都有了属于自己的答案了。那就带着自己的答案和分析继续往下看吧！")]),t._v(" "),t._m(5),t._v(" "),a("blockquote",[a("p",[t._v("前面的四个问题就比较简单，从这句开始就要考查运算符的优先级了，还不是特别清楚 JavaScript 运算符优先级的同学可以点击"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),a("OutboundLink")],1),t._v("。")])]),t._v(" "),a("ul",[t._m(6),t._v(" "),a("li",[a("p",[t._v("new Foo().getName()：还是根据 MDN 运算符来看运算符优先级，new 带参数列表调用（new Foo()）是 19，成员访问（Foo().getName）的优先级也是 19，函数调用（getName()）的优先级也是 19，所以这句代码的执行顺序就是从左到右的。可以分成两步进行分析，这里首先会用 new 操作符的形式调用构造函数 Foo，会得到 Foo 的实例，然后调用实例对象上的 getName 方法，根据前面"),a("a",{attrs:{href:"https://www.yuque.com/littlelane/javascript/nqloa2",target:"_blank",rel:"noopener noreferrer"}},[t._v("重学 new 操作符"),a("OutboundLink")],1),t._v("的分析，这条语句最终的打印结果就是 3 了；")])]),t._v(" "),t._m(7)]),t._v(" "),a("p",[t._v("最终总结一下，最后打印的结果为：2，4，1，1，2，3，3。")]),t._v(" "),a("p",[t._v("这个经典的练习题到此就分析完了对此，如果你还有什么疑问，可以在下面留言与我讨论！")])])},[function(){var t=this.$createElement,n=this._self._c||t;return n("h1",{attrs:{id:"涉及-new-、this、以及原型链经典习题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#涉及-new-、this、以及原型链经典习题","aria-hidden":"true"}},[this._v("#")]),this._v(" 涉及 new 、this、以及原型链经典习题")])},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数定义")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nFoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ul",[a("li",[t._v("L2：通过函数声明的方式创建了一个名为 Foo 的函数；")]),t._v(" "),a("li",[t._v("L3 - L5：在 Foo 函数体里面通过函数表达式的形式创建了一个名为 getName 的函数变量，当函数执行时会打印出 1；")]),t._v(" "),a("li",[t._v("L6：显式的 return Foo 函数的作用域 this；")]),t._v(" "),a("li",[t._v("L9 - L11：为函数 Foo 添加一个静态方法 getName，当方法被调用时会输出 2；")]),t._v(" "),a("li",[t._v("L13 - L15：在函数 Foo 原型 prototype 上添加一个名为 getName 的方法，当方法被调用时会输出 3；")]),t._v(" "),a("li",[t._v("L17 - L19：利用函数表达式的形式定义全局的 getName 方法，当方法被调用时会输出 4；")]),t._v(" "),a("li",[t._v("L21 - L23：利用函数声明的方式定义名为 getName 的方法，当方法被调用时会输出 5。")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("1、函数 Foo 里面以定义函数表达式的形式创建的名为 getName 的函数变量，默认是得不到解析的，只有当函数 Foo 被调用后，才会被解析，所以在调用函数 Foo 前后，环境变量是有差异的；")]),this._v(" "),n("li",[this._v("2、函数 Foo 是否通过 new 操作符进行调用，逻辑显式的 return 的 this 值是不同的；")]),this._v(" "),n("li",[this._v("3、关于属性的查找，静态属性比原型链属性优先级更高，也就是若存在同名的属性，静态属性会更先被找到；")]),this._v(" "),n("li",[this._v("4、通过函数声明方式来声明函数有声明提升的特性，而且函数声明提升的优先级高于变量声明提升。")])])},function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ouput:")]),t._v("\nFoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[n("p",[this._v("Foo.getName()：直接通过 Foo 点的方式进行调用，肯定是找到了 Foo 的静态方法和 prototype 原型链方法，而根据我们之前分析的坑点 3，可以得到 Foo.getName 调用的是 L9 - L11 这段代码，所以输出 2；")])]),this._v(" "),n("li",[n("p",[this._v("getName()：直接执行 getName 方法肯定是执行的挂载在全局环境 window 下面的方法了。在此之前 Foo 并没有被调用，根据上面的坑点 1 分析，这里肯定不会打印 1；接下往下看，L17 - L23 用函数表达式和函数声明这两种方式声明了两个同名 getName 的函数，根据上面分析的坑点 4 可知，函数声明方式会将声明提升到函数表达式的前面执行，于是有了函数表达式覆盖函数声明的情况，最终的打印结果就是 4 了；")])]),this._v(" "),n("li",[n("p",[this._v("Foo().getName()：这条语句会先调用 Foo 函数，在通过 Foo() 调用函数是通过普通函数进行调用的，函数体返回的 this 指向当前调用的上下文，也就是 window 了；根据上面分析的坑点 1 可知，在调用 Foo 函数时，会执行里面的通过函数表达式的方式声明 getName 函数并将其挂载在全局 window 下，所以 Foo().getName() 的执行等价于 window.getName()，所以打印结果为 1；")])]),this._v(" "),n("li",[n("p",[this._v("getName()：根据上一点结合坑点 1 的分析，函数 Foo 被调用后，作用域中的 getName 就发生了变化，所以最终的打印结果还是 1；")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("li",[n("p",[this._v("new Foo.getName()：关于这条语句，我们可以先来分析一下各部分的优先级。根据 MDN 运算符优先级列表，我们不难发现成员访问（Foo.getName）的优先级是 19，new 无参数列表调用（new Foo）是 18，函数调用（getName()）的优先级是 19，所以这条语句从左往右划分就等价于 "),n("code",[this._v("new (Foo.getName)()")]),this._v("  ，先执行 Foo.getName，然后将调用的结果通过 new 操作符进行调用。首先看 Foo.getName 的调用，根据上面第 1 条的分析，Foo.getName 最终会得到 L9 - L11 定义的方法，然后通过 new 操作符执行，最终的打印结果就是 2 了；")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("li",[n("p",[this._v("new new Foo().getName()：这条语句就相对比较复杂了，但是同样可以转换为运算符优先级的问题：new 无参数列表调用（new Foo）是 18，new 带参数列表调用（new Foo()）是 19，成员访问（new Foo().getName）的优先级是 19，函数调用（getName()）的优先级也是 19。所以从左到右第一步就是 new 带参数列表调用（new Foo()），就可以转化为 "),n("code",[this._v("new (new Foo()).getName()")]),this._v(" ，第二步就是成员访问，可转换为 "),n("code",[this._v("new ((new Foo()).getName)()")]),this._v(" ，于是最终的调用顺序就是："),n("strong",[this._v("先初始化 Foo 的实例化对象，然后将其原型上的 getName 函数作为构造函数再次调用 new 操作符，所以最终结果为 3")]),this._v("；")])])}],!1,null,null,null);n.default=e.exports}}]);